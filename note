I need help fixing my node js backend : 

I need to adjust the ngo.controller.js :
const NGO = require('../models/ngo.model');

// Create a new NGO, associating it with the authenticated user
exports.createNGO = async (req, res, next) => {
  try {
    const ngoData = req.body;
    const newNGO = await NGO.create({
      ...ngoData,
      createdBy: req.user.id // Associate NGO with creator
    });

    res.status(201).json({
      success: true,
      data: newNGO
    });
  } catch (error) {
    next(error);
  }
};

// Retrieve all NGOs
exports.getAllNGOs = async (req, res, next) => {
  try {
    const ngos = await NGO.getAll();
    res.status(200).json({
      success: true,
      count: ngos.length,
      data: ngos
    });
  } catch (error) {
    next(error);
  }
};

// Retrieve a specific NGO by ID
exports.getNGOById = async (req, res, next) => {
  try {
    const ngo = await NGO.getById(req.params.id);
    if (!ngo) {
      return res.status(404).json({
        success: false,
        message: 'NGO not found'
      });
    }

    res.status(200).json({
      success: true,
      data: ngo
    });
  } catch (error) {
    next(error);
  }
};

How can we make the partners be moderated? Or even edited Incase of mistake, Lets add a update and delete endpoint for the user that has the ngo.

Also, for the admin , : The admin account should be able to delete any NGO from the ngos the users created, The admin account should be able to add other admin as well. If isAdmin, then they can make role admin for registered users, make the role updateable by only isAdmin.

admin.controller.js:

const User = require('../models/user.model');
const { ErrorHandler } = require('../utils/errorHandler');

exports.getAllUsers = async (req, res, next) => {
  try {
    console.log(`Admin access granted to: ${req.user.email}`);
    
    const users = await User.getAll();
    
    res.status(200).json({
      success: true,
      count: users.length,
      data: users
    });
  } catch (error) {
    next(error);
  }
};


Do you understand ? 

see the auth.controller.js as well : 

const jwt = require('jsonwebtoken');
const User = require('../models/user.model');
const { comparePassword } = require('../utils/passwordUtils');
const jwtConfig = require('../config/jwtConfig');
const { ErrorHandler } = require('../utils/errorHandler');

// Register a new user
exports.register = async (req, res, next) => {
  try {
    const { email, password, name } = req.body;
    
    if (!email || !password) {
      throw new ErrorHandler(400, 'Email and password are required');
    }

    const user = await User.create({ email, password, name });
    
    res.status(201).json({
      success: true,
      data: user
    });
  } catch (error) {
    next(error);
  }
};

// Login user and issue JWT
exports.login = async (req, res, next) => {
  try {
    const { email, password } = req.body;
    
    if (!email || !password) {
      throw new ErrorHandler(400, 'Email and password are required');
    }

    const user = await User.findByEmail(email);
    if (!user) {
      throw new ErrorHandler(401, 'Invalid credentials');
    }

    const isMatch = await comparePassword(password, user.password);
    if (!isMatch) {
      throw new ErrorHandler(401, 'Invalid credentials');
    }

    // Include the user's role in the token payload
    const tokenPayload = { 
      id: user.id, 
      email: user.email, 
      role: user.role
    };

    // Sign access token
    const token = jwt.sign(
      tokenPayload,
      jwtConfig.secret,
      { expiresIn: jwtConfig.expiresIn }
    );

    // Omit password from response
    const { password: _, ...userWithoutPassword } = user;

    res.status(200).json({
      success: true,
      token,
      data: userWithoutPassword
    });
  } catch (error) {
    next(error);
  }
};

// Get logged-in user's profile
exports.getMe = async (req, res, next) => {
  try {
    const user = await User.findById(req.user.id);
    if (!user) {
      throw new ErrorHandler(404, 'User not found');
    }

    // Omit password from response
    const { password: _, ...userWithoutPassword } = user;

    res.status(200).json({
      success: true,
      data: userWithoutPassword
    });
  } catch (error) {
    next(error);
  }
};


see the ngo.model.js:
const db = require('../config/firebase');

class NGO {
  constructor(data) {
    this.name = data.name;
    this.description = data.description;
    this.accountNumber = data.accountNumber;
    this.bankName = data.bankName || '';
    this.accountName = data.accountName || '';
    this.website = data.website || '';
    this.contactEmail = data.contactEmail || '';
    this.imageUrl = data.imageUrl || '';
    this.createdBy = data.createdBy || '';
    this.createdAt = new Date().toISOString();
    this.updatedAt = new Date().toISOString();
  }

  // Create a new NGO document
  static async create(ngoData) {
    const ngoRef = db.collection('ngos').doc();
    const ngoInstance = new NGO(ngoData);
    await ngoRef.set(ngoInstance.toJSON());
    return { id: ngoRef.id, ...ngoData };
  }

  // Get all NGOs
  static async getAll() {
    const snapshot = await db.collection('ngos').get();
    return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
  }

  // Get a specific NGO by ID
  static async getById(id) {
    const doc = await db.collection('ngos').doc(id).get();
    if (!doc.exists) {
      throw new Error('NGO not found');
    }
    return { id: doc.id, ...doc.data() };
  }

  // Convert instance to JSON (for Firestore)
  toJSON() {
    return {
      name: this.name,
      description: this.description,
      accountNumber: this.accountNumber,
      bankName: this.bankName,
      accountName: this.accountName,
      website: this.website,
      contactEmail: this.contactEmail,
      imageUrl: this.imageUrl,
      createdBy: this.createdBy,
      createdAt: this.createdAt,
      updatedAt: this.updatedAt
    };
  }
}

module.exports = NGO;


see the user.model.js:

const db = require('../config/firebase');
const { hashPassword } = require('../utils/passwordUtils');

class User {
  constructor(data) {
    this.email = data.email;
    this.password = data.password;
    this.name = data.name || '';
    this.role = data.role || 'user';
    this.createdAt = new Date().toISOString();
    this.updatedAt = new Date().toISOString();
  }

  // Create new user
  static async create(userData) {
    const { email, password } = userData;

    // Prevent duplicate users
    const existingUser = await this.findByEmail(email);
    if (existingUser) {
      throw new Error('User already exists');
    }

    // Hash password
    const hashedPassword = await hashPassword(password);
    const userRef = db.collection('users').doc();

    // Save user data (including hashed password)
    await userRef.set({
      ...new User({ ...userData, password: hashedPassword }).toJSON(),
      password: hashedPassword
    });

    return { id: userRef.id, email, name: userData.name };
  }

  // Find user by email
  static async findByEmail(email) {
    const snapshot = await db.collection('users')
      .where('email', '==', email)
      .limit(1)
      .get();

    if (snapshot.empty) return null;
    const doc = snapshot.docs[0];
    return { id: doc.id, ...doc.data() };
  }

  // Find user by ID
  static async findById(id) {
    const doc = await db.collection('users').doc(id).get();
    if (!doc.exists) return null;
    return { id: doc.id, ...doc.data() };
  }

  // Get all users (omit passwords)
  static async getAll() {
    const snapshot = await db.collection('users').get();
    return snapshot.docs.map(doc => {
      const data = doc.data();
      const { password, ...userWithoutPassword } = data;
      return { id: doc.id, ...userWithoutPassword };
    });
  }

  // Convert to JSON (exclude password)
  toJSON() {
    return {
      email: this.email,
      name: this.name,
      role: this.role,
      createdAt: this.createdAt,
      updatedAt: this.updatedAt
    };
  }
}

// Create default admin user if not exists
(async () => {
  try {
    const adminEmail = 'mabu@bigrelief.com';
    const adminExists = await User.findByEmail(adminEmail);

    if (!adminExists) {
      await User.create({
        email: adminEmail,
        password: 'admin001',
        name: 'Admin User',
        role: 'admin'
      });
      console.log('Default admin user created');
    }
  } catch (error) {
    console.error('Error creating default admin:', error);
  }
})();

module.exports = User;



And fnally the routes : 

ngo.routes.js:

const express = require('express');
const router = express.Router();
const ngoController = require('../controllers/ngo.controller');
const { authenticate } = require('../middlewares/auth.middleware');

router.post('/ngos', authenticate, ngoController.createNGO);
router.get('/ngos', ngoController.getAllNGOs);
router.get('/ngos/:id', ngoController.getNGOById);

module.exports = router;


auth.routes.js: 

const express = require('express');
const router = express.Router();
const authController = require('../controllers/auth.controller');

// Public routes
router.post('/register', authController.register);
router.post('/login', authController.login);

// Protected route (example)
router.get('/me', authController.getMe);

module.exports = router;

admin.routes.js:

const express = require('express');
const router = express.Router();
const adminController = require('../controllers/admin.controller');
const { authenticate, isAdmin } = require('../middlewares/auth.middleware');

// Admin-only routes
router.get('/users', authenticate, isAdmin, adminController.getAllUsers);

module.exports = router;


With all these informations, help me modify and also show me how to document the endpoints for all the routes. 

Generate full codes for all these node.js backend fixes. 